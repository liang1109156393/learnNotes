package com.zxl.basic.redis;

/**
 * @author :zhangxiaoliang
 * @date :2022/3/8 16:10
 * redis安装模式:
 * 单机:一个redis实例,
 * 优点:安装简单,容易维护,不存在数据同步问题
 * 缺点:宕机的风险
 * 主从:master节点(负责读写数据和数据同步)、salve节点(只负责读数据)。
 * 哨兵模式:多个哨兵节点,主从复制节点(读写数据)。
 * 集群模式:多个主从复制模式的集合。
 */
public class MyRedis {
    /**
     * redis:key过期删除策略
     *①、定时删除
     * 　　在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。
     * 　　优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。
     * 　　缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。
     * ②、惰性删除
     * 　　设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。
     * 　　优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。
     * 　　缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。
     * ③、定期删除
     * 　　每隔一段时间，我们就对一些key进行检查，删除里面过期的key。
     * 　　优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。
     * 　　缺点：难以确定删除操作执行的时长和频率。
     * 　　　　　如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。
     * 　　　　　如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。
     * 　　　　　另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。
     *
     * */


     /* 内存淘汰策略
     1. noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键

     2. allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键

     3. volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键

     4. allkeys-random：加入键的时候如果过限，从所有key随机删除

     5. volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐

     6. volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键

     7. volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键

     8. allkeys-lfu：从所有键中驱逐使用频率最少的键
     */
    /** 一、缓存穿透数据库
     * 访问一个不存在的key，缓存不起做用，请求会穿透到DB，流量大时DB会挂掉。缓存
     解决方案
     （1）采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；
     （2）拦截器，id<=0的直接拦截。
     （3）从cache和db都取不到，能够将key-value写为key-null，设置较短过时时间，如30秒（设置太长会致使正常状况也无法使用）。这样能够防止攻击用户反复用同一个id暴力攻击
     二、缓存击穿
     一个存在的key，在缓存过时的一刻，同时有大量的请求，这些请求都会击穿到DB，形成瞬时DB请求量大、压力骤增。svg
     解决方案
     （1）设置热点数据永远不过时。
     （2）加互斥锁。
     三、缓存雪崩
     大量的key设置了相同的过时时间，致使在缓存在同一时刻所有失效，形成瞬时DB请求量大、压力骤增，引发雪崩。xml
     解决方案
     （1）缓存数据的过时时间设置随机，防止同一时间大量数据过时现象发生。
     （2）若是缓存数据库是分布式部署，将热点数据均匀分布在不一样搞得缓存数据库中。
     （3）设置热点数据永远不过时
     * */
}
